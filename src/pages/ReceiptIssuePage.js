// src/pages/ReceiptIssuePage.js
import React, { useEffect, useMemo, useRef, useState, forwardRef } from "react";
import { db } from "../firebase";
import {
  collection,
  onSnapshot,
  query,
  orderBy,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  serverTimestamp,
} from "firebase/firestore";

import DataTable from "../components/DataTable";
import PageTitle from "../components/PageTitle";
import ReceiptPreviewModal from "../components/ReceiptPreviewModal";

import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";
import { format } from "date-fns";
import { ko } from "date-fns/locale";
import "remixicon/fonts/remixicon.css";

import "./ReceiptIssuePage.css";
import { useLocation } from "react-router-dom"; // ‚úÖ ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú ÎÑòÍ∏¥ ?row= ÌååÎùºÎØ∏ÌÑ∞ ÏùΩÍ∏∞

/* ===== Ïú†Ìã∏ ===== */
const s = (v) => String(v ?? "").trim();
const parseNumber = (v) => parseInt(String(v ?? "").replace(/[^0-9]/g, ""), 10) || 0;
const fmtComma = (n) => (parseNumber(n) ? parseNumber(n).toLocaleString() : "");
const today = () => format(new Date(), "yyyy-MM-dd");
const MAX_ITEMS = 15;

/* ÏïàÏ†ÑÌïú Date ÌååÏÑú */
function parseToDate(v) {
  if (v == null || v === "") return null;
  if (v instanceof Date) return isNaN(v.getTime()) ? null : v;
  if (typeof v === "number") {
    if (v > 20000 && v < 60000) {
      const ms = Math.round((v - 25569) * 86400 * 1000);
      const d = new Date(ms);
      return isNaN(d.getTime()) ? null : d;
    }
    const d = new Date(v);
    return isNaN(d.getTime()) ? null : d;
  }
  let sVal = String(v).trim().replace(/[./]/g, "-");
  if (/^\d{2}-\d{2}-\d{2}$/.test(sVal)) {
    const [yy, mm, dd] = sVal.split("-");
    sVal = `20${yy}-${mm}-${dd}`;
  }
  if (/^\d{4}-\d{2}-\d{2}$/.test(sVal)) {
    const d = new Date(`${sVal}T00:00:00`);
    return isNaN(d.getTime()) ? null : d;
  }
  const d = new Date(sVal);
  return isNaN(d.getTime()) ? null : d;
}

/* ‚úÖ ÌëúÍ∏∞ ÌÜµÏùºÏö©: Ïñ¥Îñ§ ÏûÖÎ†•Ïù¥ Îì§Ïñ¥ÏôÄÎèÑ yyyy-MM-dd Î°ú Ï†ïÍ∑úÌôî */
function normalizeToYMD(v) {
  const d = parseToDate(v);
  return d ? format(d, "yyyy-MM-dd") : s(v);
}

/* ===== ÎÇ†Ïßú Ïù∏Ìíã ===== */
const DPInput = forwardRef(function DPInput(
  // ‚úÖ placeholder ÏÑ§Î™Ö Ï†úÍ±∞ (ÏöîÏ≤≠ÏÇ¨Ìï≠)
  { value, onClick, placeholder = "", clearable = false },
  ref
) {
  return (
    <div className="date-field" data-clear={clearable ? "true" : "false"} onClick={onClick}>
      <input ref={ref} className="date-inner" value={value || ""} onClick={onClick} readOnly placeholder={placeholder} />
      <i className="ri-calendar-line date-icon" />
    </div>
  );
});

function AutoCloseDate({ selected, onChange, isClearable = false, placeholder = "" }) {
  const [open, setOpen] = useState(false);
  const inputRef = useRef(null);
  const closeNow = () => setTimeout(() => { setOpen(false); inputRef.current?.blur(); }, 0);
  const handleSelect = (date) => { onChange(date); closeNow(); };
  return (
    <DatePicker
      selected={selected}
      onChange={handleSelect}
      onSelect={handleSelect}
      open={open}
      onInputClick={() => setOpen(true)}
      onClickOutside={closeNow}
      onCalendarClose={() => setOpen(false)}
      preventOpenOnFocus
      shouldCloseOnSelect
      dateFormat="yyyy-MM-dd"
      locale={ko}
      isClearable={isClearable}
      popperPlacement="bottom-start"
      portalId="datepicker-portal"
      // ‚úÖ placeholder ÏÑ§Î™Ö Ï†úÍ±∞
      customInput={<DPInput ref={inputRef} placeholder={placeholder} clearable={isClearable} />}
    />
  );
}

/* ===== Í≥µÌÜµ ÏΩ§Î≥¥ ===== */
function ComboShell({ children, open, setOpen, boxRef }) {
  useEffect(() => {
    const onDocClick = (e) => {
      if (!boxRef.current) return;
      if (!boxRef.current.contains(e.target)) setOpen(false);
    };
    document.addEventListener("mousedown", onDocClick);
    return () => document.removeEventListener("mousedown", onDocClick);
  }, [boxRef, setOpen]);
  return <div className="combo-wrap" ref={boxRef}>{children}</div>;
}

function ReceiptNameCombo({ value, onChange }) {
  const options = useMemo(() => ["ÏòÅÏàòÏ¶ù", "Ïù¥ÏÇ¨Ï†ïÏÇ∞ ÏòÅÏàòÏ¶ù", "ÌïúÎÇ®Ï£ºÌÉùÍ¥ÄÎ¶¨ ÏòÅÏàòÏ¶ù"], []);
  const [open, setOpen] = useState(false);
  const boxRef = useRef(null);
  const inputRef = useRef(null);
  const onSelect = (val) => { onChange(val); setOpen(false); inputRef.current?.blur(); };

  return (
    <ComboShell open={open} setOpen={setOpen} boxRef={boxRef}>
      <div className="combo-input">
        <input
          ref={inputRef}
          className="input"
          value={value}
          onFocus={() => setOpen(true)}
          onClick={() => setOpen(true)}
          onChange={(e) => { onChange(e.target.value); setOpen(true); }}
        />
        <i className="ri-arrow-down-s-line combo-caret" onMouseDown={(e) => { e.preventDefault(); setOpen((v) => !v); }} />
      </div>
      {open && (
        <div className="combo-pop">
          <div className="combo-panel">
            <div className="combo-items stylish">
              {options.map((opt) => (
                <button key={opt} type="button" className="combo-item btnlike"
                        onMouseDown={(e) => { e.preventDefault(); onSelect(opt); }}>
                  {opt}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </ComboShell>
  );
}

/* üîÅ CodeCombo (ÎàÑÎùΩÎêú Ï†ïÏùò Î≥¥Í∞ï) */
function CodeCombo({ value, onChange, onSelectOption, options }) {
  const [open, setOpen] = useState(false);
  const [filter, setFilter] = useState("");
  const boxRef = useRef(null);
  const inputRef = useRef(null);
  const list = useMemo(() => {
    const f = s(filter);
    return options.filter((v) => (f ? v.code.includes(f) || v.name.includes(f) : true)).slice(0, 300);
  }, [filter, options]);
  const onSelect = (code) => {
    onChange(code);
    setOpen(false);
    setFilter("");
    inputRef.current?.blur();
    onSelectOption?.(code);
  };

  return (
    <ComboShell open={open} setOpen={setOpen} boxRef={boxRef}>
      <div className="combo-input">
        <input
          ref={inputRef}
          className="input"
          value={value}
          onFocus={() => setOpen(true)}
          onClick={() => setOpen(true)}
          onChange={(e) => { onChange(e.target.value); setFilter(e.target.value); setOpen(true); }}
        />
        <i className="ri-arrow-down-s-line combo-caret" onMouseDown={(e) => { e.preventDefault(); setOpen((v) => !v); }} />
      </div>
      {open && (
        <div className="combo-pop">
          <div className="combo-panel">
            <div className="combo-search">
              <i className="ri-search-line" />
              <input className="combo-search-input" value={filter} onChange={(e) => setFilter(e.target.value)} placeholder="ÏΩîÎìú/Ïù¥Î¶Ñ Í≤ÄÏÉâ" />
            </div>
            <div className="combo-items stylish">
              {list.length === 0 ? (
                <div className="combo-empty">Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§</div>
              ) : (
                list.map((v) => (
                  <button key={v.id} type="button" className="combo-item btnlike"
                          onMouseDown={(e) => { e.preventDefault(); onSelect(v.code); }}>
                    <b className="ci-code">{v.code}</b><span className="ci-name">{v.name}</span>
                  </button>
                ))
              )}
            </div>
          </div>
        </div>
      )}
    </ComboShell>
  );
}

/* ‚úÖ BillingCombo: placeholder Ï†úÍ±∞(ÏöîÏ≤≠ÏÇ¨Ìï≠) + useRef Ï°∞Í±¥ Ìò∏Ï∂ú Í∏àÏßÄ */
function BillingCombo({ value, onChange, openTick = 0, externInputRef = null }) {
  const options = ["Î¨∏Ïûê", "Ìå©Ïä§", "Ïπ¥ÌÜ°", "Ïù¥Î©îÏùº", "ÌÖîÎ†àÍ∑∏Îû®", "Î≥¥Î•ò"];
  const [open, setOpen] = useState(false);
  const boxRef = useRef(null);
  const innerRef = useRef(null);
  const inputRef = externInputRef ?? innerRef;

  const onSelect = (val) => { onChange(val); setOpen(false); inputRef.current?.blur(); };

  useEffect(() => {
    if (openTick > 0) {
      setOpen(true);
      setTimeout(() => inputRef.current?.focus(), 0);
    }
  }, [openTick, inputRef]);

  return (
    <ComboShell open={open} setOpen={setOpen} boxRef={boxRef}>
      <div className="combo-input">
        <input
          ref={inputRef}
          className="input"
          value={value}
          // ‚úÖ placeholder ÏÑ§Î™Ö Ï†úÍ±∞
          onFocus={() => setOpen(true)}
          onClick={() => setOpen(true)}
          onChange={(e) => { onChange(e.target.value); setOpen(true); }}
        />
        <i className="ri-arrow-down-s-line combo-caret" onMouseDown={(e) => { e.preventDefault(); setOpen((v) => !v); }} />
      </div>
      {open && (
        <div className="combo-pop">
          <div className="combo-panel">
            <div className="combo-items stylish">
              {options.map((opt) => (
                <button key={opt} type="button" className="combo-item btnlike"
                        onMouseDown={(e) => { e.preventDefault(); onSelect(opt); }}>
                  {opt}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}
    </ComboShell>
  );
}

/* ===== Î©îÏù∏ ===== */
export default function ReceiptIssuePage() {
  const [rows, setRows] = useState([]);
  const [villas, setVillas] = useState([]);
  const [previewOpen, setPreviewOpen] = useState(false);
  const [previewRow, setPreviewRow] = useState(null);

  const [editOpen, setEditOpen] = useState(false);
  const [editMode, setEditMode] = useState("create");
  const [editRowId, setEditRowId] = useState(null);

  const [form, setForm] = useState(blankForm());
  const [items, setItems] = useState([blankItem()]);
  const [unpaidOnly, setUnpaidOnly] = useState(false);

  const itemDateRefs = useRef([]);
  const itemDescRefs = useRef([]);
  const itemQtyRefs = useRef([]);
  const itemPriceRefs = useRef([]);

  const unitRef = useRef(null);
  const recipientRef = useRef(null);
  const receiverRef = useRef(null);
  const billingInputRef = useRef(null);
  const [billingOpenTick, setBillingOpenTick] = useState(0);

  const [tip, setTip] = useState({ show: false, x: 0, y: 0, content: "" });
  const showTip = (content, e) => setTip({ show: true, x: e.clientX + 12, y: e.clientY + 12, content });
  const moveTip = (e) => setTip((t) => ({ ...t, x: e.clientX + 12, y: e.clientY + 12 }));
  const hideTip = () => setTip((t) => ({ ...t, show: false }));

  // ‚úÖ ÎåÄÏãúÎ≥¥Îìú ÎØ∏ÏàòÍ∏à Ìå®ÎÑêÏóêÏÑú ÎÑòÏñ¥Ïò® row ÌïòÏù¥ÎùºÏù¥Ìä∏Ïö© ÌååÎùºÎØ∏ÌÑ∞
  const { search } = useLocation();
  const params = new URLSearchParams(search);
  const focusRowId = params.get("row") || ""; // DataTableÏùò focusIdÎ°ú ÎÑòÍπÄ

  function blankForm() {
    return {
      issueDate: today(),
      receiptName: "ÌïúÎÇ®Ï£ºÌÉùÍ¥ÄÎ¶¨ ÏòÅÏàòÏ¶ù",
      code: "",
      address: "",
      villaName: "",
      unitNumber: "",
      recipient: "",
      receiver: "",
      billingMethod: "",
      depositDate: "",
      note: "",
    };
  }
  function blankItem() {
    return { date: "", description: "", qty: 1, unitPrice: "", amount: 0 };
  }

  /* Î™©Î°ù/ÎπåÎùº Î°úÎî© */
  useEffect(() => {
    const qx = query(collection(db, "receipts"), orderBy("issueDate", "desc"));
    return onSnapshot(qx, (snap) => {
      const list = snap.docs.map((d) => {
        const data = d.data();
        const its = Array.isArray(data.items) ? data.items : [];
        const total = Number((data.totalAmount ?? data.amount) || 0);
        const summary =
          s(data.description) ||
          (its.length ? (its.length === 1 ? s(its[0].description) : `${s(its[0].description)} Ïô∏ ${its.length - 1}Í±¥`) : "");
        return {
          id: d.id,
          // ‚úÖ ÎÇ†Ïßú ÌëúÍ∏∞ Ï†ïÍ∑úÌôî (25-09-12 ‚Üí 2025-09-12)
          issueDate: normalizeToYMD(data.issueDate || ""),
          receiptName: s(data.receiptName || "ÌïúÎÇ®Ï£ºÌÉùÍ¥ÄÎ¶¨ ÏòÅÏàòÏ¶ù"),
          address: s(data.address || ""),
          villaName: s(data.villaName || ""),
          unitNumber: s(data.unitNumber || ""),
          amount: total,
          description: summary,
          billingMethod: s(data.billingMethod || ""),
          receiver: s(data.receiver || ""),
          // ‚úÖ ÎÇ†Ïßú ÌëúÍ∏∞ Ï†ïÍ∑úÌôî
          depositDate: normalizeToYMD(data.depositDate || ""),
          note: s(data.note || ""),
          code: s(data.code || ""),
          recipient: s(data.recipient || ""),
          items: its,
        };
      });
      setRows(list);
    });
  }, []);

  useEffect(() => {
    const qx = query(collection(db, "villas"), orderBy("code", "asc"));
    return onSnapshot(qx, (snap) => {
      const list = snap.docs.map((d) => {
        const data = d.data();
        return { id: d.id, code: s(data.code || ""), name: s(data.name || ""), address: s(data.address || "") };
      });
      setVillas(list);
    });
  }, []);

  const buildTooltip = (row) => {
    const arr = Array.isArray(row.items) ? row.items : [];
    if (!arr.length) return row.amount ? `Ï¥ùÏï° : ${Number(row.amount).toLocaleString()}Ïõê` : "";
    const lines = arr.map((it) => {
      const desc = s(it?.description);
      const amt = Number(it?.amount ?? (Number(it?.qty || 0) * parseNumber(it?.unitPrice)));
      return `${desc || "-"} : ${isNaN(amt) ? 0 : amt.toLocaleString()}Ïõê`;
    });
    return lines.join("\n");
  };

  /* ‚úÖ ÏπºÎüº ÏàúÏÑú: ÎÇ¥Ïö© ‚Üí Í∏àÏï° */
  const columns = useMemo(
    () => [
      { key: "issueDate", label: "Î∞úÌñâÏùºÏûê", width: 110 },
      { key: "address", label: "Ï£ºÏÜå", width: 220 },
      { key: "villaName", label: "ÎπåÎùºÎ™Ö", width: 120 },
      { key: "unitNumber", label: "ÎÇòÎ®∏ÏßÄÏ£ºÏÜå", width: 80 },
      {
        key: "description",
        label: "ÎÇ¥Ïö©",
        width: 260,
        render: (row) => {
          const summary = s(row.description || "") || "-";
          const tipText = buildTooltip(row);
          return (
            <span className="desc-ellipsis" onMouseEnter={(e) => showTip(tipText, e)} onMouseMove={moveTip} onMouseLeave={hideTip}>
              {summary}
            </span>
          );
        },
      },
      { key: "amount", label: "Í∏àÏï°", width: 110, render: (row) => (row.amount ? row.amount.toLocaleString() : "") },
      { key: "receiver", label: "Î∞õÎäîÏÇ¨Îûå", width: 120 },
      { key: "billingMethod", label: "Ï≤≠Íµ¨Î∞©Î≤ï", width: 120 },
      { key: "depositDate", label: "ÏûÖÍ∏àÎÇ†Ïßú", width: 110 },
      // ‚úÖ ÎπÑÍ≥†Í∞Ä Í∏∏Ïñ¥ÎèÑ ÌÖåÏù¥Î∏îÏùÑ Î∞ÄÏßÄ ÏïäÍ≤å: ÎßêÏ§ÑÏûÑ + ÎßàÏö∞Ïä§Ïò§Î≤Ñ Ìà¥ÌåÅ
      {
        key: "note",
        label: "ÎπÑÍ≥†",
        width: 160,
        render: (row) => {
          const note = s(row.note);
          if (!note) return "";
          return (
            <span
              className="note-ellipsis"
              onMouseEnter={(e) => showTip(note, e)}
              onMouseMove={moveTip}
              onMouseLeave={hideTip}
              title=""
            >
              {note}
            </span>
          );
        },
      },
      {
        key: "receipt",
        label: "ÏòÅÏàòÏ¶ù",
        width: 80,
        render: (row) => (
          <button className="receipt-icon" title="ÏòÅÏàòÏ¶ù ÎØ∏Î¶¨Î≥¥Í∏∞" onClick={() => onPreview(row)}>
            <span className="emoji">üìë</span>
          </button>
        ),
      },
    ],
    [] // eslint-disable-line
  );

  const searchableKeys = [
    "issueDate","address","villaName","unitNumber","description","billingMethod","depositDate","note","code","recipient","receiver","receiptName"
  ];

  const unpaidRows = useMemo(() => rows.filter((r) => !s(r.depositDate)), [rows]);
  const unpaidSum = useMemo(() => unpaidRows.reduce((acc, r) => acc + (Number(r.amount) || 0), 0), [unpaidRows]);
  const shownData = useMemo(() => (unpaidOnly ? unpaidRows : rows), [unpaidOnly, rows, unpaidRows]);

  const onPreview = (row) => { setPreviewRow(row); setPreviewOpen(true); };

  /* ===== Ï†ÄÏû•/ÏàòÏ†ï ===== */
  const computeItems = () =>
    items
      .filter((it) => s(it.description) || parseNumber(it.unitPrice) || Number(it.qty))
      .map((it) => {
        const qty = Number(it.qty || 0);
        const unitPrice = parseNumber(it.unitPrice);
        const amount = qty * unitPrice;
        return {
          date: s(it.date),
          description: s(it.description),
          qty,
          unitPrice,
          amount,
        };
      });

  const computeTotal = (its) => its.reduce((sum, it) => sum + (Number(it.amount) || 0), 0);

  const handleSubmit = async () => {
    const issueDate = s(form.issueDate);
    if (!issueDate) { alert("Î∞úÌñâÏùºÏûêÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî."); return; }

    const payload = {
      issueDate,
      receiptName: s(form.receiptName) || "ÌïúÎÇ®Ï£ºÌÉùÍ¥ÄÎ¶¨ ÏòÅÏàòÏ¶ù",
      code: s(form.code),
      address: s(form.address),
      villaName: s(form.villaName),
      unitNumber: s(form.unitNumber),
      recipient: s(form.recipient),
      receiver: s(form.receiver),
      billingMethod: s(form.billingMethod),
      depositDate: s(form.depositDate),
      note: s(form.note),
      items: computeItems(),
    };
    payload.totalAmount = computeTotal(payload.items);
    payload.description = payload.items.length
      ? (payload.items.length === 1 ? s(payload.items[0].description) : `${s(payload.items[0].description)} Ïô∏ ${payload.items.length - 1}Í±¥`)
      : s(form.note);

    try {
      if (editMode === "edit" && editRowId) {
        await updateDoc(doc(db, "receipts", editRowId), { ...payload, updatedAt: serverTimestamp() });
        alert("ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.");
      } else {
        await addDoc(collection(db, "receipts"), { ...payload, createdAt: serverTimestamp() });
        alert("Î∞úÌñâÎêòÏóàÏäµÎãàÎã§.");
      }
      setEditOpen(false);
      setForm(blankForm());
      setItems([blankItem()]);
      setEditMode("create");
      setEditRowId(null);
    } catch (e) {
      console.error(e);
      alert("Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
    }
  };

  /* Ìé∏Ïßë Ïó¥Í∏∞/ÏÇ≠Ï†ú/Ï∂îÍ∞Ä */
  const onEdit = (row) => {
    setEditMode("edit");
    setEditRowId(row.id);
    setForm({
      // ‚úÖ Ìé∏Ïßë Î™®Îã¨Ïóê Îì§Ïñ¥Ïò¨ ÎïåÎèÑ yyyy-MM-dd Î°ú Î≥¥Ïù¥ÎèÑÎ°ù Ï†ïÍ∑úÌôî
      issueDate: normalizeToYMD(row.issueDate || today()),
      receiptName: row.receiptName || "ÌïúÎÇ®Ï£ºÌÉùÍ¥ÄÎ¶¨ ÏòÅÏàòÏ¶ù",
      code: row.code || "",
      address: row.address || "",
      villaName: row.villaName || "",
      unitNumber: row.unitNumber || "",
      recipient: row.recipient || "",
      receiver: row.receiver || "",
      billingMethod: row.billingMethod || "",
      depositDate: normalizeToYMD(row.depositDate || ""),
      note: row.note || "",
    });
    setItems(
      (row.items || []).length
        ? row.items.map((it) => ({
            date: normalizeToYMD(it.date || ""),
            description: s(it.description || ""),
            qty: Number(it.qty || 0),
            unitPrice: fmtComma(it.unitPrice),
            amount: Number(it.amount || 0),
          }))
        : [blankItem()]
    );
    setEditOpen(true);
  };

  const onDelete = async (row) => {
    if (!window.confirm("ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) return;
    await deleteDoc(doc(db, "receipts", row.id));
  };

  const onAdd = () => {
    setEditMode("create");
    setEditRowId(null);
    setForm(blankForm());
    setItems([blankItem()]);
    setEditOpen(true);
  };

  /* ÏΩîÎìú ÏÑ†ÌÉù Ïãú Ï£ºÏÜå/ÎπåÎùºÎ™Ö ÏûêÎèô Ï±ÑÏõÄ */
  useEffect(() => {
    const v = villas.find((x) => x.code === s(form.code));
    if (v) setForm((f) => ({ ...f, address: v.address || "", villaName: v.name || "" }));
  }, [form.code, villas]);

  const ensureNextRowAndFocusDesc = (idx) => {
    if (items.length <= idx + 1) {
      setItems((l) => {
        if (l.length <= idx + 1) return [...l, blankItem()];
        return l;
      });
      setTimeout(() => { itemDescRefs.current[idx + 1]?.focus(); }, 0);
    } else {
      itemDescRefs.current[idx + 1]?.focus();
    }
  };

  const setItemField = (idx, key, value) => {
    setItems((list) => {
      const next = [...list];
      const cur = { ...next[idx] };
      if (key === "qty") cur.qty = parseNumber(value) || 0;
      else if (key === "unitPrice") {
        const only = String(value || "").replace(/[^0-9]/g, "");
        cur.unitPrice = only.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      } else cur[key] = value;
      const up = parseNumber(cur.unitPrice);
      cur.amount = (Number(cur.qty || 0) * up) || 0;
      next[idx] = cur;
      return next;
    });
  };

  const addItem = () => {
    setItems((l) => {
      if (l.length >= MAX_ITEMS) {
        alert(`ÌíàÎ™©ÏùÄ ÏµúÎåÄ ${MAX_ITEMS}Í∞úÍπåÏßÄ Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§.`);
        return l;
      }
      return [...l, blankItem()];
    });
  };

  const removeItem = (idx) => setItems((l) => (l.length > 1 ? l.filter((_, i) => i !== idx) : l));

  const totalAmount = useMemo(() => items.reduce((s2, it) => s2 + (Number(it.amount) || 0), 0), [items]);

  /* ====== Enter Ïù¥Îèô(ÏöîÏ≤≠ ÎèôÏÑ†) ====== */
  const onEnterTo = (nextAction) => (e) => {
    if (e.key !== "Enter" || e.isComposing) return;
    e.preventDefault();
    nextAction?.();
  };

  return (
    <div className="page-wrapper">
      <PageTitle>ÏòÅÏàòÏ¶ùÎ∞úÌñâ</PageTitle>

      <div id="datepicker-portal" />

      <div className="receipt-page">
        <DataTable
          columns={columns}
          data={shownData}
          searchableKeys={searchableKeys}
          itemsPerPage={15}
          sortKey="issueDate"
          sortOrder="desc"
          onAdd={onAdd}
          addButtonLabel="Î∞úÌñâ"
          addButtonIcon="üßæ"
          onEdit={onEdit}
          onDelete={onDelete}
          enableExcel={true}
          collectionName="receipts"
          appendWithoutId={true}
          excelFields={[
            "issueDate","address","villaName","unitNumber","amount","description",
            "receiver","billingMethod","depositDate","note","code","recipient","receiptName"
          ]}
          leftControls={
            <div className="chip-row">
              <button
                type="button"
                className={`btn-chip ${unpaidOnly ? "on" : ""}`}
                onClick={() => setUnpaidOnly((v) => !v)}
                title="ÏûÖÍ∏àÎÇ†ÏßúÍ∞Ä ÎπÑÏñ¥ÏûàÎäî Ìï≠Î™©Îßå Î≥¥Í∏∞"
              >
                ÎØ∏ÏàòÍ∏à
              </button>
              <div className="badge-unpaid-sum">
                Ìï©Í≥Ñ&nbsp;<b>{unpaidSum.toLocaleString()}</b>&nbsp;Ïõê
              </div>
            </div>
          }
          focusId={focusRowId}  // ‚úÖ ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú ÎÑòÏñ¥Ïò® ÌäπÏ†ï ÏòÅÏàòÏ¶ù ÌñâÏùÑ ÌïòÏù¥ÎùºÏù¥Ìä∏/Ïä§ÌÅ¨Î°§
          rowIdKey="id"         // ‚úÖ focusÏö© ÌÇ§ ÏßÄÏ†ï (Ïù¥Í≤å ÏóÜÏñ¥ÏÑú ÌïòÏù¥ÎùºÏù¥Ìä∏Í∞Ä Ïïà Î≥¥ÏòÄÏùå)
        />

        {editOpen && (
          <>
            <div className="modal-backdrop" onClick={() => setEditOpen(false)} />
            <div className="modal modal-neo modal-compact">
              <div className="modal-head">
                <div className="title">{editMode === "edit" ? "ÏòÅÏàòÏ¶ù ÏàòÏ†ï" : "ÏòÅÏàòÏ¶ù Î∞úÌñâ"}</div>
                <div className="right">
                  <span className="badge-total">Ìï©Í≥Ñ {totalAmount.toLocaleString()} Ïõê</span>
                </div>
              </div>

              <div className="modal-body">
                <div className="neo-form-shell">
                  <div className="neo-form-grid grid-3">
                    <LabeledInput label="ÏòÅÏàòÏ¶ù Ïù¥Î¶Ñ">
                      <ReceiptNameCombo value={form.receiptName} onChange={(val) => setForm((f) => ({ ...f, receiptName: val }))} />
                    </LabeledInput>

                    <LabeledInput label="Î∞úÌñâÏùºÏûê">
                      <AutoCloseDate
                        selected={parseToDate(form.issueDate)}
                        onChange={(date) => setForm((f) => ({ ...f, issueDate: date ? format(date, "yyyy-MM-dd") : "" }))}
                      />
                    </LabeledInput>

                    <LabeledInput label="ÏΩîÎìúÎ≤àÌò∏">
                      <CodeCombo
                        value={form.code}
                        onChange={(val) => setForm((f) => ({ ...f, code: val }))}
                        onSelectOption={() => unitRef.current?.focus()}
                        options={villas}
                      />
                    </LabeledInput>

                    <LabeledInput label="Ï£ºÏÜå">
                      <input className="input" value={form.address} onChange={(e) => setForm((f) => ({ ...f, address: e.target.value }))} />
                    </LabeledInput>

                    <LabeledInput label="ÎπåÎùºÎ™Ö">
                      <input className="input" value={form.villaName} onChange={(e) => setForm((f) => ({ ...f, villaName: e.target.value }))} />
                    </LabeledInput>

                    <LabeledInput label="ÎÇòÎ®∏ÏßÄÏ£ºÏÜå">
                      <input
                        ref={unitRef}
                        className="input"
                        value={form.unitNumber}
                        onChange={(e) => setForm((f) => ({ ...f, unitNumber: e.target.value }))}
                        onKeyDown={onEnterTo(() => recipientRef.current?.focus())}
                      />
                    </LabeledInput>

                    <LabeledInput label="Í≥µÍ∏âÎ∞õÎäîÏûê">
                      <input
                        ref={recipientRef}
                        className="input"
                        value={form.recipient}
                        onChange={(e) => setForm((f) => ({ ...f, recipient: e.target.value }))}
                        onKeyDown={onEnterTo(() => receiverRef.current?.focus())}
                      />
                    </LabeledInput>

                    <LabeledInput label="Î∞õÎäî ÏÇ¨Îûå">
                      <input
                        ref={receiverRef}
                        className="input"
                        value={form.receiver}
                        onChange={(e) => setForm((f) => ({ ...f, receiver: e.target.value }))}
                        onKeyDown={onEnterTo(() => {
                          setBillingOpenTick((t) => t + 1);
                          setTimeout(() => billingInputRef.current?.focus(), 0);
                        })}
                      />
                    </LabeledInput>

                    <LabeledInput label="Ï≤≠Íµ¨Î∞©Î≤ï">
                      <BillingCombo
                        value={form.billingMethod}
                        onChange={(val) => setForm((f) => ({ ...f, billingMethod: val }))}
                        openTick={billingOpenTick}
                        externInputRef={billingInputRef}
                      />
                    </LabeledInput>

                    <LabeledInput label="ÏûÖÍ∏àÎÇ†Ïßú">
                      <AutoCloseDate
                        selected={parseToDate(form.depositDate)}
                        onChange={(date) => setForm((f) => ({ ...f, depositDate: date ? format(date, "yyyy-MM-dd") : "" }))}
                        isClearable
                      />
                    </LabeledInput>

                    <LabeledInput label="ÎπÑÍ≥†">
                      <input className="input" value={form.note} onChange={(e) => setForm((f) => ({ ...f, note: e.target.value }))} />
                    </LabeledInput>

                    <div className="neo-empty" />
                  </div>
                </div>

                {/* ÌíàÎ™© ÌÖåÏù¥Î∏î */}
                <div className="card section neo-items">
                  <div className="table-head center small">
                    <div>ÎÇ†Ïßú</div><div>ÌíàÎ™©(ÎÇ¥Ïö©)</div><div>ÏàòÎüâ</div><div>Îã®Í∞Ä</div><div>Í∏àÏï°</div><div></div>
                  </div>

                  {items.map((it, idx) => (
                    <div className="table-row center" key={idx}>
                      <div className="col-date">
                        <div className="date-item">
                          <DatePicker
                            selected={parseToDate(it.date)}
                            onChange={(date) => {
                              setItemField(idx, "date", date ? format(date, "yyyy-MM-dd") : "");
                              setTimeout(() => itemDescRefs.current[idx]?.focus(), 0);
                            }}
                            dateFormat="yyyy-MM-dd"
                            locale={ko}
                            isClearable
                            shouldCloseOnSelect
                            popperPlacement="bottom-start"
                            portalId="datepicker-portal"
                            // ‚úÖ placeholder ÏÑ§Î™Ö Ï†úÍ±∞
                            customInput={<DPInput ref={(el) => (itemDateRefs.current[idx] = el)} clearable />}
                          />
                        </div>
                      </div>
                      <div>
                        <input
                          ref={(el) => (itemDescRefs.current[idx] = el)}
                          className="input"
                          value={it.description}
                          onChange={(e) => setItemField(idx, "description", e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === "Enter") {
                              e.preventDefault();
                              itemPriceRefs.current[idx]?.focus();
                            }
                          }}
                        />
                      </div>
                      <div>
                        <input
                          ref={(el) => (itemQtyRefs.current[idx] = el)}
                          type="number"
                          className="input"
                          min="0"
                          value={it.qty}
                          onChange={(e) => setItemField(idx, "qty", e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === "Enter") {
                              e.preventDefault();
                              itemPriceRefs.current[idx]?.focus();
                            }
                          }}
                        />
                      </div>
                      <div>
                        <input
                          ref={(el) => (itemPriceRefs.current[idx] = el)}
                          className="input"
                          inputMode="numeric"
                          value={it.unitPrice}
                          onChange={(e) => setItemField(idx, "unitPrice", e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === "Enter") {
                              e.preventDefault();
                              ensureNextRowAndFocusDesc(idx);
                            }
                          }}
                        />
                      </div>
                      <div className="amount">{(Number(it.amount) || 0).toLocaleString()} Ïõê</div>
                      <div className="row-actions">
                        <button className="icon-btn danger" title="Ìñâ ÏÇ≠Ï†ú" onClick={() => removeItem(idx)}>
                          <i className="ri-close-line" />
                        </button>
                      </div>
                    </div>
                  ))}

                  <div className="table-foot">
                    <button className="btn-outline add-item" onClick={addItem} type="button">
                      <i className="ri-add-line" /> Ìï≠Î™© Ï∂îÍ∞Ä
                    </button>
                    <div className="sum">Ìï©Í≥Ñ <b>{totalAmount.toLocaleString()}</b> Ïõê</div>
                  </div>
                </div>
              </div>

              <div className="modal-actions neo-actions">
                <button className="btn-primary same btn-lg" onClick={handleSubmit}>
                  {editMode === "edit" ? "ÏàòÏ†ï" : "Î∞úÌñâ"}
                </button>
                <button className="btn-neutral same btn-lg" onClick={() => setEditOpen(false)}>
                  Îã´Í∏∞
                </button>
              </div>
            </div>
          </>
        )}

        {tip.show && <div className="hover-tooltip" style={{ top: tip.y, left: tip.x }}>{tip.content}</div>}

        <ReceiptPreviewModal
          open={previewOpen}
          row={{ ...previewRow, receiptName: previewRow?.receiptName || form.receiptName }}
          onClose={() => { setPreviewOpen(false); setPreviewRow(null); }}
        />
      </div>
    </div>
  );
}

function LabeledInput({ label, children, onClickLabel }) {
  return (
    <label className="labeled" onClick={onClickLabel}>
      <span className="lab">{label}</span>
      {children}
    </label>
  );
}
